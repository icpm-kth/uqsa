test_that("simfi produces a solution for AKAR4",{
	f <- uqsa_example('AKAR4')
	expect_vector(f, ptype = character(0))
	sb <- SBtabVFGEN::sbtab_from_tsv(f)
	expect_type(sb,"list")
	expect_equal(length(f),length(sb))
	sink("/dev/null")
	suppressMessages({
		ex <- SBtabVFGEN::sbtab.data(sb)
	})
	sink()
	m <- SBtabVFGEN::sbtab_to_vfgen(sb,cla=FALSE)
	suppressWarnings({
		C <- generateCode(m)
	})
	expect_type(C,"character")
	cat(C,sep='\n',file='./AKAR4_gvf.c')
	suppressMessages({
		modelName <- checkModel(comment(sb),'./AKAR4_gvf.c')
	})
	s <- simfi(ex,modelName,parMap=log10ParMap)
	p <- log10(sb$Parameter[['!DefaultValue']])
	expect_vector(p, ptype = numeric(0), size=NROW(sb$Parameter))
	rprior <- rNormalPrior(mean=p,sd=rep_len(0.1,length(p)))
	N <- 10
	X <- rprior(N)
	y <- s(t(X))
	expect_equal(length(y),length(ex))
	expect_equal(dim(y[[1]]$state),c(NROW(sb$Compound),length(ex[[1]]$outputTimes),N))
	expect_false(is.null(y[[1]]$FisherInformation))
	expect_false(is.null(y[[1]]$gradLogLikelihood))
	expect_false(is.null(y[[1]]$logLikelihood))
	expect_false(is.null(y[[1]]$func))
	expect_false(is.null(y[[1]]$state))
})

test_that("simfi produces a solution for AKAR4, without Fisher Information",{
	f <- uqsa_example('AKAR4')
	expect_vector(f, ptype = character(0))
	sb <- SBtabVFGEN::sbtab_from_tsv(f)
	expect_type(sb,"list")
	expect_equal(length(f),length(sb))
	ex <- SBtabVFGEN::sbtab.data(sb)
	sink("/dev/null")
	suppressMessages({
		m <- SBtabVFGEN::sbtab_to_vfgen(sb,cla=FALSE)
	})
	sink()
	suppressWarnings({
		C <- generateCode(m)
	})
	expect_type(C,"character")
	cat(C,sep='\n',file='./AKAR4_gvf.c')
	modelName <- checkModel(comment(sb),'./AKAR4_gvf.c')
	s <- simfi(ex,modelName,parMap=log10ParMap,omit=1)
	p <- log10(sb$Parameter[['!DefaultValue']])
	expect_vector(p, ptype = numeric(0), size=NROW(sb$Parameter))
	rprior <- rNormalPrior(mean=p,sd=rep_len(0.1,length(p)))
	N <- 10
	X <- rprior(N)
	y <- s(t(X))
	expect_equal(length(y),length(ex))
	expect_equal(dim(y[[1]]$state),c(NROW(sb$Compound),length(ex[[1]]$outputTimes),N))
	expect_true(is.null(y[[1]]$FisherInformation))
	expect_false(is.null(y[[1]]$gradLogLikelihood))
	expect_false(is.null(y[[1]]$logLikelihood))
	expect_false(is.null(y[[1]]$func))
	expect_false(is.null(y[[1]]$state))
})

test_that("simfi produces a solution for AKAR4, without Fisher Information, and gradient of log-likelihood",{
	f <- uqsa_example('AKAR4')
	expect_vector(f, ptype = character(0))
	sink("/dev/null")
	sb <- SBtabVFGEN::sbtab_from_tsv(f)
	expect_type(sb,"list")
	expect_equal(length(f),length(sb))
	ex <- SBtabVFGEN::sbtab.data(sb)
	suppressMessages({
		m <- SBtabVFGEN::sbtab_to_vfgen(sb,cla=FALSE)
	})
	sink()
	suppressWarnings({
		C <- generateCode(m)
	})
	expect_type(C,"character")
	cat(C,sep='\n',file='./AKAR4_gvf.c')
	modelName <- checkModel(comment(sb),'./AKAR4_gvf.c')
	s <- simfi(ex,modelName,parMap=log10ParMap,omit=2)
	p <- log10(sb$Parameter[['!DefaultValue']])
	expect_vector(p, ptype = numeric(0), size=NROW(sb$Parameter))
	rprior <- rNormalPrior(mean=p,sd=rep_len(0.1,length(p)))
	N <- 10
	X <- rprior(N)
	y <- s(t(X))
	expect_equal(length(y),length(ex))
	expect_equal(dim(y[[1]]$state),c(NROW(sb$Compound),length(ex[[1]]$outputTimes),N))
	expect_true(is.null(y[[1]]$FisherInformation))
	expect_true(is.null(y[[1]]$gradLogLikelihood))
	expect_false(is.null(y[[1]]$logLikelihood))
	expect_false(is.null(y[[1]]$func))
	expect_false(is.null(y[[1]]$state))
})

test_that("simfi produces a solution for AKAR4, omit all optionals",{
	f <- uqsa_example('AKAR4')
	expect_vector(f, ptype = character(0))
	sb <- SBtabVFGEN::sbtab_from_tsv(f)
	expect_type(sb,"list")
	expect_equal(length(f),length(sb))
	sink("/dev/null")
	ex <- SBtabVFGEN::sbtab.data(sb)
	suppressMessages({
		m <- SBtabVFGEN::sbtab_to_vfgen(sb,cla=FALSE)
	})
	sink()
	suppressWarnings({
		C <- generateCode(m)
	})
	expect_type(C,"character")
	cat(C,sep='\n',file='./AKAR4_gvf.c')
	modelName <- checkModel(comment(sb),'./AKAR4_gvf.c')
	s <- simfi(ex,modelName,parMap=log10ParMap,omit=3)
	p <- log10(sb$Parameter[['!DefaultValue']])
	expect_vector(p, ptype = numeric(0), size=NROW(sb$Parameter))
	rprior <- rNormalPrior(mean=p,sd=rep_len(0.1,length(p)))
	N <- 10
	X <- rprior(N)
	y <- s(t(X))
	expect_equal(length(y),length(ex))
	expect_equal(dim(y[[1]]$state),c(NROW(sb$Compound),length(ex[[1]]$outputTimes),N))
	expect_true(is.null(y[[1]]$FisherInformation))
	expect_true(is.null(y[[1]]$gradLogLikelihood))
	expect_true(is.null(y[[1]]$logLikelihood))
	expect_false(is.null(y[[1]]$func))
	expect_false(is.null(y[[1]]$state))
})
