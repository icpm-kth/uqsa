#library(parallel)
#library(VineCopula)
#library(MASS)
#library(ks)
#library(R.utils)
library(UQ)
library(rgsl)
remotes::install_github("a-kramer/rgsl")
remotes::install_github("a-kramer/rgsl")
remotes::install_github("a-kramer/rgsl@cc")
system("gcc --version")
#!/bin/env mpirun
library(parallel)
library(Rmpi)
T<-Sys.time()
cl<-makeCluster(4,type="MPI")
res<-unlist(parLapply(cl,seq(10000),function(x) sqrt(x)))
T<-Sys.time()-T
save(list=c("T","res"),file="square_roots_1_to_100.Rdata")
mpi.finalize()
rm(cl)
library(Rmpi)
library(snow)
T<-Sys.time()
#cl<-snow::makeCluster(4,type="MPI")
cl<-snow::makeMPIcluster(4)
getMPIcluster()
remotes::install_github("a-kramer/rgsl")
remotes::install_github("a-kramer/SBtabVFGEN")
library(rgsl)
library(SBtabVFGEN)
library(UQ)
preCalibration()
preCalibration
remotes::install_github("a-kramer/rgsl")
remotes::install_github("a-kramer/SBtabVFGEN")
library(rgsl)
library(SBtabVFGEN)
library(UQ)
getwd()
setwd("Documents/uqsa/AKAP79/")
SBtabDir <- getwd()
model = import_from_SBtab(SBtabDir)
#modelName <- checkModel(comment(model),paste0(comment(model),'.R'))
modelName <- checkModel(comment(model),paste0(comment(model),'_gvf.c'))
parVal <- model[["Parameter"]][["!DefaultValue"]]
parNames <- model[["Parameter"]][["!Name"]]
# load experiments
experiments <- import_experiments(modelName, SBtabDir)
# scale to determine prior values
defRange <- 1000
# Define Lower and Upper Limits for logUniform prior distribution for the parameters
ll <- c(parVal[1:19]/defRange, parVal[20]/1.9, parVal[21]/defRange, parVal[22:24]/1.25, parVal[25:26]/1.5, parVal[27]/2)
ul <- c(parVal[1:19]*defRange, parVal[20]*1.9, parVal[21]*defRange, parVal[22:24]*1.25, parVal[25:26]*1.5, parVal[27]*2)
ll = log10(ll) # log10-scale
ul = log10(ul) # log10-scale
# Define the experiments that have to be considered in each iteration of the for loop to compare simulations with experimental data
experimentsIndices <- c(3, 12, 18, 9, 2, 11, 17, 8, 1, 10, 16, 7)
# Define Number of Samples for the Precalibration (npc) and each ABC-MCMC chain (ns)
ns <- 5000 # no of samples required from each ABC-MCMC chain
npc <- 5000 # pre-calibration
# Define ABC-MCMC Settings
delta <- 8 #0.01
# Define the number of Cores for the parallelization
nCores <- parallel::detectCores() %/% 2
set.seed(7619201)
# Define the score function to compare simulated data with experimental data
getScore	<- function(yy_sim, yy_exp, yy_expErr){
yy_sim <- (yy_sim-0)/(0.2-0.0)
ifelse(!is.na(yy_exp), yy_exp <- (yy_exp-100)/(171.67-100), Inf)
distance <- mean(((yy_sim-yy_exp)/(yy_expErr/(171.67-100)))^2)
#When output function is fixed:
#distance <- mean((yy_sim-yy_exp)/(yy_expErr)^2)
return(distance)
}
parMap <- function(parABC){
return(10^parABC)
}
i<-1
expInd <- experimentsIndices[i]
cat("#####Starting run for Experiments ", expInd, "######\n")
## If First Experimental Setting, Create an Independente Colupla
if(i==1){
message("- Initial Prior: uniform product distribution")
rprior <- rUniformPrior(ll, ul)
dprior <- dUniformPrior(ll, ul)
## Otherwise, Take Copula from the Previous Exp Setting and Use as a Prior
} else {
message("- New Prior: fitting Copula based on previous MCMC runs")
C <- fitCopula(draws, nCores)
rprior <- rCopulaPrior(C)
dprior <- dCopulaPrior(C)
}
## Run Pre-Calibration Sampling
message("- Precalibration")
pC <- preCalibration(experiments[expInd], modelName, parMap, npc, rprior, getScore, nCores)
