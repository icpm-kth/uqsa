experiments[[i]][["outputValues"]] <- as.matrix(experiment_table[paste(">", outputId[match_output], sep = "")])
notNAidx <- apply(!is.na(experiments[[i]][["outputValues"]]) & experiments[[i]][["outputTimes"]]>0, 1, prod)
experiments[[i]][["outputValues"]] <- experiments[[i]][["outputValues"]][as.logical(notNAidx),]
experiments[[i]][["outputTimes"]] <- experiments[[i]][["outputTimes"]][as.logical(notNAidx)]
experiments[[i]][["outputFunction"]] <- function(yy) {vectorialOutputFunction(0.0, yy, 0)[match_output]}
match_errorNames <- match(tabOutputId, errorNames)
match_errorNames <- match_errorNames[!is.na(match_errorNames)]
experiments[[i]][["errorNames"]] <- errorNames[match_errorNames]
experiments[[i]][["errorValues"]] <- as.matrix(experiment_table[paste(">", errorNames[match_errorNames], sep = "")])
experiments[[i]][["errorValues"]] <- experiments[[i]][["errorValues"]][as.logical(notNAidx),]
}
return(experiments)
}
# Uncertainty Quantification: ABC-MCMC with copulas
# Federica Milinanni (fedmil@kth.se)
# (based on: Copyright (C) 2018 Alexandra Jauhiainen (alexandra.jauhiainen@gmail.com)
# and based on modifications: 2021 by Joao Antunes (joaodgantunes@gmail.com) and Olivia Eriksson (olivia@kth.se))
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License or
# (at your option) any later version.
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#' Performs and Approximate Bayesian Computation Sampling of Model Parameters
#'
#' Given a set of simulation experiments (list), a model, parameter
#' boundaries, this function will draw a sample of parameters from the
#' posterior probability density of the given problem.
#'
#' Initially this function performs a similar job as an optimizer, and
#' then transitions to MCMC sampling.
#'
#' @export
#' @param experiments a list of experiments
#' @param modelName model functions will be assumed to have this
#'     prefix (comment(modelName) can contain a file-name)
#' @param startPar starting value for the parameter vector
#' @param parMap re-mapping function between the ABC MCMC variables and model
#'     parameters
#' @param nSims requested sample size
#' @param Sigma0 multivariate normal covariance of Markov chain
#'     transition kernel
#' @param delta ABC acceptance threshold
#' @param dprior a function that returns prior probability density
#'     values
#' @param getScore a function(model_output,experiment) that returns
#'     scores
#' @param nCores setting for multicore package
#' @return a list containing a sample matrix and a vector of scores (values of delta for each sample)
ABCMCMC <- function(startPar, nSims, Sigma0, delta, dprior){
cat("Started chain.\n")
Sigma1 <- 0.25*diag(diag(Sigma0))
curDelta <- Inf
np <- length(startPar)
scount <- 1
curPar  <- startPar
curDelta <- mean(objectiveFunction(curPar))
if(is.na(curDelta)){
cat("*** [ABCMCMC] curDelta is NA. Replacing it with Inf ***\n")
curDelta <- Inf
}
curPrior <- dprior(curPar)
draws <- matrix(NA, nSims,np)
scores <- rep(NA, nSims)
n <- 0
acceptedSamples <- 0
nRegularizations <- 0
sampleFrequency <- 100 #50
while (n/sampleFrequency < nSims){
if(scount>max(nSims/1, 500)){
nRegularizations <- nRegularizations + 1
if(nRegularizations >= 3){
timeStr <- Sys.time()
timeStr <- gsub(":","_", timeStr)
timeStr <- gsub(" ","_", timeStr)
save(draws, file = paste0("AbortedChainAfterRegularization_",timeStr,".RData"))
stop(paste0("Stuck chain (nRegularizations = ", nRegularizations,")"))
}
disp(paste0("Regularization of proposal covariance matrix (nRegularizations = ", nRegularizations,")"))
Sigma0 <- solve(solve(Sigma0)+solve(0.1*norm(Sigma0)*diag(1,np,np)))
Sigma1 <- 0.25*diag(diag(Sigma0))
draws <- matrix(NA, nSims,np)
scores <- rep(NA, nSims)
scount <- 1
n <- 0
}
if(runif(1)<=0.95){
canPar <- mvrnorm(n=1, curPar, Sigma0)
}else{
canPar <- mvrnorm(n=1, curPar, Sigma1)
}
out <- parUpdate(objectiveFunction, curPar, canPar, curDelta, curPrior, delta, dprior)
curPar <- out$curPar
curDelta <- out$curDelta
curPrior <- out$curPrior
scount <- ifelse(out$acceptance, 1, scount + 1) #scount counts the number of times we are in the same value for curPar. If we accept a new canPar, then we reset the count to 1.
acceptedSamples <- acceptedSamples + out$acceptance
n <- n+1
if(n %% sampleFrequency == 0){
draws[n/sampleFrequency,]  <- curPar
scores[n/sampleFrequency] <- curDelta
}
}
cat("Finished chain.\n")
return(list(draws = draws, scores = scores, acceptanceRate = acceptedSamples/n, nRegularizations = nRegularizations))
}
#' Updates Parameter Values
#'
#' under valid ABC update conditions (successful simulation) the
#' parameters are updated to new values.
#'
#' @export
#' @param experiments list of simulation experiments
#' @param modelName (characters), this will be used to find the model
#'     file and the functions in that file
#' @param parMap optional remapping function set for passing parameters to the
#'     model: parModel<-parMap(parABC)
#' @param curPar current parameter values (as ABC samples them)
#' @param canPar candidate parameter values (for MCMC)
#' @param curDelta current distance between data and simulation, if
#'     the MCMC chain has not yet reached any point where this is
#'     below the threshold (delta), this can be accepted as the new
#'     current state for the chain.
#' @param curPrior current Prior values given curPar
#' @param delta distance threshold for ABC
#' @param dprior prior probability density function
#' @param getScore a scoring function
#' @param nCores number of cores to use in mclapply().
#' @return updated values for curPar, curDelta, and curPrior
parUpdate <- function(objectiveFunction, curPar, canPar, curDelta, curPrior, delta, dprior){
canDelta <- mean(objectiveFunction(canPar))
if(is.na(canDelta)){
cat("\n*** [parUpdate] canDelta is NA. Replacing it with Inf ***")
canDelta <- Inf
}
canPrior <- dprior(canPar)
if (canDelta <= max(delta, curDelta)){
acceptance <- (runif(1) <= canPrior/curPrior)
if (acceptance){
curDelta <- canDelta
curPrior <- canPrior
curPar <- canPar
}
} else {
# curPar, curDelta, and curPrior remain unchanged
acceptance <- FALSE
}
return(list(curPar=curPar, curDelta=curDelta, curPrior=curPrior, acceptance=acceptance))
}
#' ABC acceptance of currently sampled values given old data (Prior)
#'
#' The prior probability density model using copulas and vines is not
#' perfect, so values sampled from an imperfect prior estimate can be
#' checked against old data.
#'
#' @export
#' @param modelName name, is used to find the file and model functions
#'     therein (comment(modelName) can contain a file-name if it
#'     differs from `modelName.R`).
#' @param draws matrix of sampled values (to be filtered).
#' @param experiments a list of experiments (all of them, or up to
#'     currentExpSet).
#' @param parMap optional remapping function:
#'     parModel<-parMap(parABC); the ABC variables will be transformed
#'     to make the parameter vector acceptable to the model. This is
#'     necessary whenever ABC sampling happens in a different space
#'     than the model parameter domain for whatever reason.
#' @param getScore scoring function.
#' @param delta the acceptance threshold.
#' @param nCores number of cores to use in parallel::mclapply() calls.
#' @return a filtered subset of acceptable parameter draws
checkFitWithPreviousExperiments <- function(draws, objectiveFunction, delta){
cat("-Checking fit with previous data\n")
nDraws = dim(draws)[1]
scores <- objectiveFunction(t(draws))
dim(scores) <- c(nDraws,length(scores)/nDraws)
acceptable <- apply(scores <= delta,1,all)
stopifnot(length(acceptable)==nDraws)
if (any(acceptable)){
draws <- draws[acceptable,]
nPickedDraws <- nrow(draws)
nonFits <- nDraws - nPickedDraws;
cat("-- ", nonFits, " samples  did not fit previous datasets")
} else {
print(scores)
warning("none of the draws have been accepted.")
}
return(draws)
}
# Uncertainty Quantification: Copula functions for ABC-MCMC
# Copyright (C) 2018 Alexandra Jauhiainen (alexandra.jauhiainen@gmail.com)
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License or
# (at your option) any later version.
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#' Makes a Probability Density Estimate (from a sample)
#'
#' Given a sample (from some probability distribution) this function
#' makes a Copula fit to the source distribution using the VineCopula
#' package.
#'
#' @export
#' @param X sample that characterizes the traget distribution (rows)
#' @param ll lower limit of x values (rows in X)
#' @param ul upper limit of x values (rows in X)
#' @param nCores passed to parallel::mclapply()
#' @return as list: vineCop, U, Z, and Y where U are marginal
#'     probability samples, Z are cummulative density values for U,
#'     and Y are the probability density values of U.
fitCopula <- function(X,nCores=detectCores()){
stopifnot(is.matrix(X))
ncx <- ncol(X)
ns <- nrow(X)
eps <- 0.1
npoints <- 5000
# randomly pick sample points
if(ns > npoints){
I <- sample(1:ns, npoints, replace=FALSE)
}else{
I <- 1:ns
}
# add max and min
I <- c(I, apply(X, 2, which.max))
I <- c(I, apply(X, 2, which.min))
I <- unique(I)
Z <- U <- Y <-  matrix(NA, length(I), ncx)
# must evaluate in real datapoints to
# keep connection between params
# this is a normal kernel, looks similar
# to using the ecdf function
for(i in 1:ncx){
minx <- min(X[,i])
maxx <- max(X[,i])
ls <- minx-eps
us <- maxx+eps
U[,i] <- X[I,i]
Z[,i] = kcde(X[,i], xmin=ls, xmax=us, eval.points = X[I,i])$estimate
Y[,i] = kde(X[,i], xmin=ls, xmax=us, eval.points = X[I,i])$estimate
}
# fit copula
vineCop <- RVineStructureSelect(Z,indeptest = T, cores = nCores)
return(list(copula=vineCop, U=U, Z=Z, Y=Y))
}
#' Copula Formulation for Uniform Prior Distributions
#'
#' Covers the (simpler) special case where the prior(x) is iid uniform.
#' The return value has the same structure as the value of fitCopula().
#'
#' @export
#' @param ll ll[i] is the lower limit of random variable x[i]
#' @param ul upper limit, analogous to ll.
#' @return list with: copula, U, Z, and Y entries.
makeIndepCopula <- function(ll, ul){
npoints <- 5000
np <- length(ll)
Z <- U <- Y <- matrix(NA, npoints, np)
for(i in 1:np){
minx <- ll[i]
maxx <- ul[i]
U[,i] <- seq(minx, maxx, length.out = npoints)
Z[,i] <- seq(0,1, length.out=npoints)
Y[,i] <- rep(1/(maxx-minx), npoints)
}
vineCop <- RVineStructureSelect(Z, family=0)
return(list(copula=vineCop, U=U, Z=Z, Y=Y))
}
# Uncertainty Quantification: ABC-MCMC with copulas
# Federica Milinanni (fedmil@kth.se)
# (based on: Copyright (C) 2018 Alexandra Jauhiainen (alexandra.jauhiainen@gmail.com)
# and based on modifications: 2021 by Joao Antunes (joaodgantunes@gmail.com) and Olivia Eriksson (olivia@kth.se))
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License or
# (at your option) any later version.
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#' Performs and Approximate Bayesian Computation Sampling of Model Parameters
#'
#' Given a set of simulation experiments (list), a model, parameter
#' boundaries, this function will draw a sample of parameters from the
#' posterior probability density of the given problem.
#'
#' Initially this function performs a similar job as an optimizer, and
#' then transitions to MCMC sampling.
#'
#' @export
#' @param experiments a list of experiments
#' @param modelName model functions will be assumed to have this
#'     prefix (comment(modelName) can contain a file-name)
#' @param startPar starting value for the parameter vector
#' @param parMap re-mapping function between the ABC MCMC variables and model
#'     parameters
#' @param nSims requested sample size
#' @param Sigma0 multivariate normal covariance of Markov chain
#'     transition kernel
#' @param delta ABC acceptance threshold
#' @param dprior a function that returns prior probability density
#'     values
#' @param getScore a function(model_output,experiment) that returns
#'     scores
#' @param nCores setting for multicore package
#' @return a list containing a sample matrix and a vector of scores (values of delta for each sample)
ABCMCMC <- function(startPar, nSims, Sigma0, delta, dprior){
cat("Started chain.\n")
Sigma1 <- 0.25*diag(diag(Sigma0))
curDelta <- Inf
np <- length(startPar)
scount <- 1
curPar  <- startPar
curDelta <- mean(objectiveFunction(curPar))
if(is.na(curDelta)){
cat("*** [ABCMCMC] curDelta is NA. Replacing it with Inf ***\n")
curDelta <- Inf
}
curPrior <- dprior(curPar)
draws <- matrix(NA, nSims,np)
scores <- rep(NA, nSims)
n <- 0
acceptedSamples <- 0
nRegularizations <- 0
sampleFrequency <- 100 #50
while (n/sampleFrequency < nSims){
if(scount>max(nSims/1, 500)){
nRegularizations <- nRegularizations + 1
if(nRegularizations >= 3){
timeStr <- Sys.time()
timeStr <- gsub(":","_", timeStr)
timeStr <- gsub(" ","_", timeStr)
save(draws, file = paste0("AbortedChainAfterRegularization_",timeStr,".RData"))
stop(paste0("Stuck chain (nRegularizations = ", nRegularizations,")"))
}
disp(paste0("Regularization of proposal covariance matrix (nRegularizations = ", nRegularizations,")"))
Sigma0 <- solve(solve(Sigma0)+solve(0.1*norm(Sigma0)*diag(1,np,np)))
Sigma1 <- 0.25*diag(diag(Sigma0))
draws <- matrix(NA, nSims,np)
scores <- rep(NA, nSims)
scount <- 1
n <- 0
}
if(runif(1)<=0.95){
canPar <- mvrnorm(n=1, curPar, Sigma0)
}else{
canPar <- mvrnorm(n=1, curPar, Sigma1)
}
out <- parUpdate(objectiveFunction, curPar, canPar, curDelta, curPrior, delta, dprior)
curPar <- out$curPar
curDelta <- out$curDelta
curPrior <- out$curPrior
scount <- ifelse(out$acceptance, 1, scount + 1) #scount counts the number of times we are in the same value for curPar. If we accept a new canPar, then we reset the count to 1.
acceptedSamples <- acceptedSamples + out$acceptance
n <- n+1
if(n %% sampleFrequency == 0){
draws[n/sampleFrequency,]  <- curPar
scores[n/sampleFrequency] <- curDelta
}
}
cat("Finished chain.\n")
return(list(draws = draws, scores = scores, acceptanceRate = acceptedSamples/n, nRegularizations = nRegularizations))
}
#' Updates Parameter Values
#'
#' under valid ABC update conditions (successful simulation) the
#' parameters are updated to new values.
#'
#' @export
#' @param experiments list of simulation experiments
#' @param modelName (characters), this will be used to find the model
#'     file and the functions in that file
#' @param parMap optional remapping function set for passing parameters to the
#'     model: parModel<-parMap(parABC)
#' @param curPar current parameter values (as ABC samples them)
#' @param canPar candidate parameter values (for MCMC)
#' @param curDelta current distance between data and simulation, if
#'     the MCMC chain has not yet reached any point where this is
#'     below the threshold (delta), this can be accepted as the new
#'     current state for the chain.
#' @param curPrior current Prior values given curPar
#' @param delta distance threshold for ABC
#' @param dprior prior probability density function
#' @param getScore a scoring function
#' @param nCores number of cores to use in mclapply().
#' @return updated values for curPar, curDelta, and curPrior
parUpdate <- function(objectiveFunction, curPar, canPar, curDelta, curPrior, delta, dprior){
canDelta <- mean(objectiveFunction(canPar))
if(is.na(canDelta)){
cat("\n*** [parUpdate] canDelta is NA. Replacing it with Inf ***")
canDelta <- Inf
}
canPrior <- dprior(canPar)
if (canDelta <= max(delta, curDelta)){
acceptance <- (runif(1) <= canPrior/curPrior)
if (acceptance){
curDelta <- canDelta
curPrior <- canPrior
curPar <- canPar
}
} else {
# curPar, curDelta, and curPrior remain unchanged
acceptance <- FALSE
}
return(list(curPar=curPar, curDelta=curDelta, curPrior=curPrior, acceptance=acceptance))
}
#' ABC acceptance of currently sampled values given old data (Prior)
#'
#' The prior probability density model using copulas and vines is not
#' perfect, so values sampled from an imperfect prior estimate can be
#' checked against old data.
#'
#' @export
#' @param modelName name, is used to find the file and model functions
#'     therein (comment(modelName) can contain a file-name if it
#'     differs from `modelName.R`).
#' @param draws matrix of sampled values (to be filtered).
#' @param experiments a list of experiments (all of them, or up to
#'     currentExpSet).
#' @param parMap optional remapping function:
#'     parModel<-parMap(parABC); the ABC variables will be transformed
#'     to make the parameter vector acceptable to the model. This is
#'     necessary whenever ABC sampling happens in a different space
#'     than the model parameter domain for whatever reason.
#' @param getScore scoring function.
#' @param delta the acceptance threshold.
#' @param nCores number of cores to use in parallel::mclapply() calls.
#' @return a filtered subset of acceptable parameter draws
checkFitWithPreviousExperiments <- function(draws, objectiveFunction, delta){
cat("-Checking fit with previous data\n")
nDraws = dim(draws)[1]
scores <- objectiveFunction(t(draws))
dim(scores) <- c(nDraws,length(scores)/nDraws)
acceptable <- apply(scores <= delta,1,all)
stopifnot(length(acceptable)==nDraws)
if (any(acceptable)){
draws <- draws[acceptable,]
nPickedDraws <- nrow(draws)
nonFits <- nDraws - nPickedDraws;
cat("-- ", nonFits, " samples  did not fit previous datasets")
} else {
print(scores)
warning("none of the draws have been accepted.")
}
return(draws)
}
# Define Number of Samples for the Precalibration (npc) and each ABC-MCMC chain (ns)
ns <- 50 # no of samples required from each ABC-MCMC chain
i
# run outer loop
out_ABCMCMC <- ABCMCMC(M$startPar, ns, M$Sigma, delta, dprior)
draws <- out_ABCMCMC$draws
scores <- out_ABCMCMC$scores
acceptanceRate <- out_ABCMCMC$acceptanceRate
nRegularizations <- out_ABCMCMC$nRegularizations
nRegularizations
acceptanceRate
scores
for(j in 1:9){
plot(draws[,j], main = paste("Par ", j, " ", parNames[j]))
}
for(j in 10:18){
plot(draws[,j], main = paste("Par ", j, " ", parNames[j]))
}
for(j in 19:27){
plot(draws[,j], main = paste("Par ", j, " ", parNames[j]))
}
for(j in 19:27){
plot(draws[,j], main = paste("Par ", j, " ", parNames[j]))
}
#HISTOGRAMS
for(j in 1:9){
plot(hist(draws[,j]), main = paste("Par ", j, " ", parNames[j]))
}
for(j in 10:18){
plot(hist(draws[,j]), main = paste("Par ", j, " ", parNames[j]))
}
for(j in 19:27){
plot(hist(draws[,j]), main = paste("Par ", j, " ", parNames[j]))
}
# Number of unique samples
dim(unique(draws))
# Acceptance rate
dim(unique(draws))[1]/dim(draws)[1]
i<-4
## If First Experimental Setting, Create an Independente Colupla
if(i==1){
message("- Initial Prior: uniform product distribution")
rprior <- rUniformPrior(ll, ul)
dprior <- dUniformPrior(ll, ul)
## Otherwise, Take Copula from the Previous Exp Setting and Use as a Prior
} else {
message("- New Prior: fitting Copula based on previous MCMC runs")
C <- fitCopula(draws, nCores)
rprior <- rCopulaPrior(C)
dprior <- dCopulaPrior(C)
}
## Run Pre-Calibration Sampling
message("- Precalibration")
pC <- preCalibration(objectiveFunction, npc, rprior)
## Get Starting Parameters from Pre-Calibration
M <- getMCMCPar(pC$prePar, pC$preDelta, delta=delta)
stopifnot(dprior(M$startPar)>0)
dprior(M$startPar)
delta
scores
plot(scores)
q()
