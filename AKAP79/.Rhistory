defRange <- 1000
# Define Lower and Upper Limits for logUniform prior distribution for the parameters
ll <- c(parVal[1:19]/defRange, parVal[20]/1.9, parVal[21]/defRange, parVal[22:24]/1.25, parVal[25:26]/1.5, parVal[27]/2)
ul <- c(parVal[1:19]*defRange, parVal[20]*1.9, parVal[21]*defRange, parVal[22:24]*1.25, parVal[25:26]*1.5, parVal[27]*2)
ll = log10(ll) # log10-scale
ul = log10(ul) # log10-scale
for(i in 1:27){
abline(v=ll[i], col="red")
abline(v=ul[i], col="green")
hist(draws[,i])
}
plot(ll)
points(ul,col="red")
points(ll,col="green")
min(draws[1])
min(draws[,1])
min(draws[,2])
for(i in 1:1){
abline(v=ll[i], col="red")
abline(v=ul[i], col="green")
hist(draws[,i])
}
dim(draws)
min(draws[,1])
max(draws[,1])
ll[1]
ul[1]
for(i in 1:1){
hist(draws[,i])
abline(v=ll[i], col="red")
abline(v=ul[i], col="green")
}
for(i in 1:27){
hist(draws[,i])
abline(v=ll[i], col="red")
abline(v=ul[i], col="green")
}
draws_probabilistiAcc<- draws
scores
acceptanceRate_probAcc<-acceptanceRate
acceptanceRate_probAcc
nRegularizations_probAcc<-nRegularizations
# Uncertainty Quantification: ABC-MCMC with copulas
# Federica Milinanni (fedmil@kth.se)
# (based on: Copyright (C) 2018 Alexandra Jauhiainen (alexandra.jauhiainen@gmail.com)
# and based on modifications: 2021 by Joao Antunes (joaodgantunes@gmail.com) and Olivia Eriksson (olivia@kth.se))
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License or
# (at your option) any later version.
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#' Performs and Approximate Bayesian Computation Sampling of Model Parameters
#'
#' Given a set of simulation experiments (list), a model, parameter
#' boundaries, this function will draw a sample of parameters from the
#' posterior probability density of the given problem.
#'
#' Initially this function performs a similar job as an optimizer, and
#' then transitions to MCMC sampling.
#'
#' @export
#' @param experiments a list of experiments
#' @param modelName model functions will be assumed to have this
#'     prefix (comment(modelName) can contain a file-name)
#' @param startPar starting value for the parameter vector
#' @param parMap re-mapping function between the ABC MCMC variables and model
#'     parameters
#' @param nSims requested sample size
#' @param Sigma0 multivariate normal covariance of Markov chain
#'     transition kernel
#' @param delta ABC acceptance threshold
#' @param dprior a function that returns prior probability density
#'     values
#' @param getScore a function(model_output,experiment) that returns
#'     scores
#' @param nCores setting for multicore package
#' @return a list containing a sample matrix and a vector of scores (values of delta for each sample)
ABCMCMC <- function(objectiveFunction, startPar, nSims, Sigma0, delta, dprior, acceptanceProbability){
cat("Started chain.\n")
Sigma1 <- 0.25*diag(diag(Sigma0))
curDelta <- Inf
np <- length(startPar)
scount <- 1
curPar  <- startPar
curDelta <- mean(objectiveFunction(curPar))
if(is.na(curDelta)){
cat("*** [ABCMCMC] curDelta is NA. Replacing it with Inf ***\n")
curDelta <- Inf
}
curPrior <- dprior(curPar)
draws <- matrix(NA, nSims,np)
scores <- rep(NA, nSims)
n <- 0
acceptedSamples <- 0
nRegularizations <- 0
sampleFrequency <- 50 #100
while (n/sampleFrequency < nSims){
if(scount>max(nSims, 500)){
nRegularizations <- nRegularizations + 1
if(nRegularizations >= 3){
timeStr <- Sys.time()
timeStr <- gsub(":","_", timeStr)
timeStr <- gsub(" ","_", timeStr)
save(draws, file = paste0("AbortedChainAfterRegularization_",timeStr,".RData"))
warning(paste0("Stuck chain (nRegularizations = ", nRegularizations,")"))
return(list(draws = c(), scores = c(), acceptanceRate = c(), nRegularizations = nRegularizations))
}
disp(paste0("Regularization of proposal covariance matrix (nRegularizations = ", nRegularizations,")"))
Sigma0 <- solve(solve(Sigma0)+solve(0.1*norm(Sigma0)*diag(1,np,np)))
Sigma1 <- 0.25*diag(diag(Sigma0))
draws <- matrix(NA, nSims,np)
scores <- rep(NA, nSims)
scount <- 1
n <- 0
acceptedSamples <- 0
}
if(runif(1)<=0.95){
canPar <- mvrnorm(n=1, curPar, Sigma0)
}else{
canPar <- mvrnorm(n=1, curPar, Sigma1)
}
out <- parUpdate(objectiveFunction, curPar, canPar, curDelta, curPrior, delta, dprior)
#out <- parUpdate_ProbabilisticAcceptance(acceptanceProbability, curPar, canPar, curPrior, dprior)
curPar <- out$curPar
#curDelta <- out$curDelta
curPrior <- out$curPrior
scount <- ifelse(out$acceptance, 1, scount + 1) #scount counts the number of times we are in the same value for curPar. If we accept a new canPar, then we reset the count to 1.
acceptedSamples <- acceptedSamples + out$acceptance
n <- n+1
if(n %% sampleFrequency == 0){
draws[n/sampleFrequency,]  <- curPar
#scores[n/sampleFrequency] <- curDelta
}
}
cat("Finished chain.\n")
return(list(draws = draws, scores = scores, acceptanceRate = acceptedSamples/n, nRegularizations = nRegularizations))
}
#' Updates Parameter Values
#'
#' under valid ABC update conditions (successful simulation) the
#' parameters are updated to new values.
#'
#' @export
#' @param experiments list of simulation experiments
#' @param modelName (characters), this will be used to find the model
#'     file and the functions in that file
#' @param parMap optional remapping function set for passing parameters to the
#'     model: parModel<-parMap(parABC)
#' @param curPar current parameter values (as ABC samples them)
#' @param canPar candidate parameter values (for MCMC)
#' @param curDelta current distance between data and simulation, if
#'     the MCMC chain has not yet reached any point where this is
#'     below the threshold (delta), this can be accepted as the new
#'     current state for the chain.
#' @param curPrior current Prior values given curPar
#' @param delta distance threshold for ABC
#' @param dprior prior probability density function
#' @param getScore a scoring function
#' @param nCores number of cores to use in mclapply().
#' @return updated values for curPar, curDelta, and curPrior
parUpdate <- function(objectiveFunction, curPar, canPar, curDelta, curPrior, delta, dprior){
canDelta <- mean(objectiveFunction(canPar))
if(is.na(canDelta)){
cat("\n*** [parUpdate] canDelta is NA. Replacing it with Inf ***")
canDelta <- Inf
}
canPrior <- dprior(canPar)
if (canDelta <= max(delta, curDelta)){
acceptance <- (runif(1) <= canPrior/curPrior)
if (acceptance){
curDelta <- canDelta
curPrior <- canPrior
curPar <- canPar
}
} else {
# curPar, curDelta, and curPrior remain unchanged
acceptance <- FALSE
}
return(list(curPar=curPar, curDelta=curDelta, curPrior=curPrior, acceptance=acceptance))
}
parUpdate_ProbabilisticAcceptance <- function(acceptanceProbability, curPar, canPar, curPrior, dprior){
canPrior <- dprior(canPar)
acceptance <- (runif(1) <= acceptanceProbability(canPar)*min(1,canPrior/curPrior))
if (acceptance){
curPrior <- canPrior
curPar <- canPar
}
return(list(curPar=curPar, curPrior=curPrior, acceptance=acceptance))
}
#' ABC acceptance of currently sampled values given old data (Prior)
#'
#' The prior probability density model using copulas and vines is not
#' perfect, so values sampled from an imperfect prior estimate can be
#' checked against old data.
#'
#' @export
#' @param modelName name, is used to find the file and model functions
#'     therein (comment(modelName) can contain a file-name if it
#'     differs from `modelName.R`).
#' @param draws matrix of sampled values (to be filtered).
#' @param experiments a list of experiments (all of them, or up to
#'     currentExpSet).
#' @param parMap optional remapping function:
#'     parModel<-parMap(parABC); the ABC variables will be transformed
#'     to make the parameter vector acceptable to the model. This is
#'     necessary whenever ABC sampling happens in a different space
#'     than the model parameter domain for whatever reason.
#' @param getScore scoring function.
#' @param delta the acceptance threshold.
#' @param nCores number of cores to use in parallel::mclapply() calls.
#' @return a filtered subset of acceptable parameter draws
checkFitWithPreviousExperiments <- function(draws, objectiveFunction, delta){
cat("\n-Checking fit with previous data\n")
nDraws = dim(draws)[1]
scores <- objectiveFunction(t(draws))
dim(scores) <- c(nDraws,length(scores)/nDraws)
acceptable <- apply(scores <= delta,1,all)
stopifnot(length(acceptable)==nDraws)
if (any(acceptable)){
draws <- draws[acceptable,]
nPickedDraws <- nrow(draws)
nonFits <- nDraws - nPickedDraws;
cat("-- ", nonFits, " samples  did not fit previous datasets")
} else {
print(scores)
warning("none of the draws have been accepted.")
}
return(draws)
}
set.seed(7619201)
# Define Number of Samples for the Precalibration (npc) and each ABC-MCMC chain (ns)
ns <- 10000 # no of samples required from each ABC-MCMC chain
i<-1
expInd <- experimentsIndices[i]
objectiveFunction <- makeObjective(experiments[expInd], modelName, getScore, parMap)
acceptanceProbability <- makeAcceptanceProbability(experiments[expInd], modelName, getAcceptanceProbability, parMap)
cat("#####Starting run for Experiments ", expInd, "######\n")
## If First Experimental Setting, Create an Independente Colupla
if(i==1){
message("- Initial Prior: uniform product distribution")
rprior <- rUniformPrior(ll, ul)
dprior <- dUniformPrior(ll, ul)
## Otherwise, Take Copula from the Previous Exp Setting and Use as a Prior
} else {
start_time_fitCopula <- Sys.time()
message("- New Prior: fitting Copula based on previous MCMC runs")
C <- fitCopula(draws, nCores)
rprior <- rCopulaPrior(C)
dprior <- dCopulaPrior(C)
cat("\nFitting copula:")
print(Sys.time()-start_time_fitCopula)
}
## Run Pre-Calibration Sampling
message("- Precalibration")
start_time_preCalibration <- Sys.time()
pC <- preCalibration(objectiveFunction, npc, rprior)
cat("\nPreCalibration:")
print(Sys.time()-start_time_preCalibration)
## Get Starting Parameters from Pre-Calibration
M <- getMCMCPar(pC$prePar, pC$preDelta, delta=delta, num = nChains)
M$startPar <- matrix(M$startPar, nChains)
for(j in 1 : nChains){
stopifnot(dprior(M$startPar[j,])>0)
}
gc()
## Run ABC-MCMC Sampling
cat(sprintf("-Running MCMC chains \n"))
start_time_ABC = Sys.time()
cl <- makeForkCluster(detectCores())
clusterExport(cl, c("objectiveFunction", "M", "ns", "delta", "dprior", "acceptanceProbability"))
out_ABCMCMC <- parLapply(cl, 1:nChains, function(j) ABCMCMC(objectiveFunction, M$startPar[j,], ns, M$Sigma, delta, dprior, acceptanceProbability))
stopCluster(cl)
draws <- c()
scores <- c()
acceptanceRate <- c()
nRegularizations <- c()
for(j in 1:nChains){
draws <- rbind(draws, out_ABCMCMC[[j]]$draws)
scores <- c(scores, out_ABCMCMC[[j]]$scores)
acceptanceRate <- c(acceptanceRate, out_ABCMCMC[[j]]$acceptanceRate)
nRegularizations <- c(nRegularizations, out_ABCMCMC[[j]]$nRegularizations)
}
end_time = Sys.time()
time_ = end_time - start_time_ABC
cat("\nABCMCMC for experimental set",i,":")
print(time_)
cat("\nRegularizations:", nRegularizations)
cat("\nAcceptance rate:", acceptanceRate)
dim(draws)
for(i in 1:27){
hist(draws[,i])
abline(v=ll[i], col="red")
abline(v=ul[i], col="green")
}
for(i in 1:27){
hist(draws[,i])
abline(v=ll[i], col="red")
abline(v=ul[i], col="green")
title(cat("Parameter ", i))
}
for(i in 1:27){
hist(draws[,i], labels = cat("Param ",i))
abline(v=ll[i], col="red")
abline(v=ul[i], col="green")
}
hist(draws[,i], labels = ("Param ",i))
for(i in 1:27){
hist(draws[,i], labels = ("Param ",i))
for(i in 1:27){
hist(draws[,i], main = cat("Par ", i))
abline(v=ll[i], col="red")
abline(v=ul[i], col="green")
}
hist(draws[,i], main = ("Par ", i))
for(i in 1:27){
hist(draws[,i], main = c("Par ", i))
abline(v=ll[i], col="red")
abline(v=ul[i], col="green")
}
ll[8]
ll[13]
for(i in 1:27){
hist(draws[,i], main = c("Par ", i), xlim = c(ll[i],ul[i]))
abline(v=ll[i], col="red")
abline(v=ul[i], col="green")
}
draws_ABC <- draws
acceptanceRate_ABC <- acceptanceRate
nRegularizations_ABC <- nRegularizations
for(i in 1:27){
hist(draws_probabilistiAcc[,i], main = c("Par ", i), xlim = c(ll[i],ul[i]))
abline(v=ll[i], col="red")
abline(v=ul[i], col="green")
}
par(mfrow=c(2,1))
for(i in 1:27){
hist(draws_ABC[,i], main = c("ABC - Par ", i), xlim = c(ll[i],ul[i]))
abline(v=ll[i], col="red")
abline(v=ul[i], col="green")
hist(draws_probabilistiAcc[,i], main = c("probAcc - Par ", i), xlim = c(ll[i],ul[i]))
abline(v=ll[i], col="red")
abline(v=ul[i], col="green")
}
par(mfrow=c(1,2))
for(i in 1:27){
hist(draws_ABC[,i], main = c("ABC - Par ", i), xlim = c(ll[i],ul[i]))
abline(v=ll[i], col="red")
abline(v=ul[i], col="green")
hist(draws_probabilistiAcc[,i], main = c("probAcc - Par ", i), xlim = c(ll[i],ul[i]))
abline(v=ll[i], col="red")
abline(v=ul[i], col="green")
}
remotes::install_github("a-kramer/rgsl")
remotes::install_github("a-kramer/SBtabVFGEN")
library(rgsl)
library(SBtabVFGEN)
library(parallel)
library(VineCopula)
library(MASS)
library(R.utils)
library(ks)
library(deSolve)
#library(reshape2)
#library(ggplot2)
#library(UQ)
source("../UQ/R/ABCMCMCFunctions.R")
source("../UQ/R/copulaFunctions.R")
source("../UQ/R/import_from_SBtab.R")
source("../UQ/R/PreCalibration.R")
source("../UQ/R/prior.R")
source("../UQ/R/runModel.R")
SBtabDir <- getwd()
model = import_from_SBtab(SBtabDir)
#modelName <- checkModel(comment(model),paste0(comment(model),'.R'))
#modelName <- checkModel(comment(model),paste0(comment(model),'_gvf.c'))
modelName <- checkModel(comment(model),paste0(comment(model),'.so'))
#source(paste(SBtabDir,"/",modelName,".R",sep=""))
parVal <- model[["Parameter"]][["!DefaultValue"]]
names(parVal)<-model[["Parameter"]][["!Name"]]
parNames <- model[["Parameter"]][["!Name"]]
# load experiments
experiments <- import_experiments(modelName, SBtabDir)
parMap <- function(parABC){
return(10^parABC)
}
# test simulation
print(experiments[[1]][['input']])
print(parVal)
out <- runModel(experiments, modelName, as.matrix(parVal), parMap)
# scale to determine prior values
defRange <- 1000
# Define Lower and Upper Limits for logUniform prior distribution for the parameters
ll <- c(parVal[1:19]/defRange, parVal[20]/1.9, parVal[21]/defRange, parVal[22:24]/1.25, parVal[25:26]/1.5, parVal[27]/2)
ul <- c(parVal[1:19]*defRange, parVal[20]*1.9, parVal[21]*defRange, parVal[22:24]*1.25, parVal[25:26]*1.5, parVal[27]*2)
ll = log10(ll) # log10-scale
ul = log10(ul) # log10-scale
# Define the experiments that have to be considered in each iteration of the for loop to compare simulations with experimental data
experimentsIndices <- c(3, 12, 18, 9, 2, 11, 17, 8, 1, 10, 16, 7)
# Define Number of Samples for the Precalibration (npc) and each ABC-MCMC chain (ns)
ns <- 1000 # no of samples required from each ABC-MCMC chain
npc <- 5000 # pre-calibration
# Define ABC-MCMC Settings
delta <- 7 #0.01
# Define the number of Cores for the parallelization
nCores <- 20 #parallel::detectCores() %/% 2
nChains <- 4
set.seed(7619201)
# Define the score function to compare simulated data with experimental data
getScore	<- function(yy_sim, yy_exp, yy_expErr){
yy_sim <- (yy_sim-0)/(0.2-0.0)
ifelse(!is.na(yy_exp), yy_exp <- (yy_exp-100)/(171.67-100), Inf)
distance <- mean(((yy_sim-yy_exp)/(yy_expErr/(171.67-100)))^2, na.rm=TRUE)
#When output function is fixed:
#distance <- mean((yy_sim-yy_exp)/(yy_expErr)^2, na.rm=TRUE)
return(distance)
}
getAcceptanceProbability <- function(yy_sim, yy_exp, yy_expErr){
yy_sim <- (yy_sim-0)/(0.2-0.0)
ifelse(!is.na(yy_exp), yy_exp <- (yy_exp-100)/(171.67-100), Inf)
yy_expErr <- yy_expErr/(171.67-100)
return(exp(-sum((yy_sim-yy_exp)^2/(2*yy_expErr),na.rm = TRUE)))
}
start_time = Sys.time()
for (i in 1:length(experimentsIndices)){
expInd <- experimentsIndices[i]
objectiveFunction <- makeObjective(experiments[expInd], modelName, getScore, parMap)
acceptanceProbability <- makeAcceptanceProbability(experiments[expInd], modelName, getAcceptanceProbability, parMap)
cat("#####Starting run for Experiments ", expInd, "######\n")
## If First Experimental Setting, Create an Independente Colupla
if(i==1){
message("- Initial Prior: uniform product distribution")
rprior <- rUniformPrior(ll, ul)
dprior <- dUniformPrior(ll, ul)
## Otherwise, Take Copula from the Previous Exp Setting and Use as a Prior
} else {
start_time_fitCopula <- Sys.time()
message("- New Prior: fitting Copula based on previous MCMC runs")
C <- fitCopula(draws, nCores)
rprior <- rCopulaPrior(C)
dprior <- dCopulaPrior(C)
cat("\nFitting copula:")
print(Sys.time()-start_time_fitCopula)
}
## Run Pre-Calibration Sampling
message("- Precalibration")
start_time_preCalibration <- Sys.time()
pC <- preCalibration(objectiveFunction, npc, rprior)
cat("\nPreCalibration:")
print(Sys.time()-start_time_preCalibration)
## Get Starting Parameters from Pre-Calibration
M <- getMCMCPar(pC$prePar, pC$preDelta, delta=delta, num = nChains)
M$startPar <- matrix(M$startPar, nChains)
for(j in 1 : nChains){
stopifnot(dprior(M$startPar[j,])>0)
}
gc()
## Run ABC-MCMC Sampling
cat(sprintf("-Running MCMC chains \n"))
start_time_ABC = Sys.time()
cl <- makeForkCluster(detectCores())
clusterExport(cl, c("objectiveFunction", "M", "ns", "delta", "dprior", "acceptanceProbability"))
out_ABCMCMC <- parLapply(cl, 1:nChains, function(j) ABCMCMC(objectiveFunction, M$startPar[j,], ns, M$Sigma, delta, dprior, acceptanceProbability))
stopCluster(cl)
draws <- c()
scores <- c()
acceptanceRate <- c()
nRegularizations <- c()
for(j in 1:nChains){
draws <- rbind(draws, out_ABCMCMC[[j]]$draws)
scores <- c(scores, out_ABCMCMC[[j]]$scores)
acceptanceRate <- c(acceptanceRate, out_ABCMCMC[[j]]$acceptanceRate)
nRegularizations <- c(nRegularizations, out_ABCMCMC[[j]]$nRegularizations)
}
end_time = Sys.time()
time_ = end_time - start_time_ABC
cat("\nABCMCMC for experimental set",i,":")
print(time_)
cat("\nRegularizations:", nRegularizations)
cat("\nAcceptance rate:", acceptanceRate)
if (i>1){
precursors <- experimentsIndices[1:(i-1)]
objectiveFunction <- makeObjective(experiments[precursors], modelName, getScore, parMap, nCores)
draws <- checkFitWithPreviousExperiments(draws, objectiveFunction, delta)
}
cat("\nNumber of draws after fitting with previous experiments:",dim(draws)[1])
# Save Resulting Samples to MATLAB and R files.
cat("\n-Saving sample \n")
outFile <- paste(experimentsIndices[1:i], collapse="_")
timeStr <- Sys.time()
timeStr <- gsub(":","_", timeStr)
timeStr <- gsub(" ","_", timeStr)
outFileR <- paste("../PosteriorSamples/Draws",modelName,"nChains",nChains,"ns",ns,"npc",npc,outFile,timeStr,".RData",collapse="_",sep="_")
save(draws, parNames, file=outFileR)
#if (require(R.matlab)){
#	outFileM <- paste("../PosteriorSamples/Draws",modelName,"ns",ns,"npc",npc,outFile,timeStr,".mat",collapse="_",sep="_")
#	writeMat(outFileM, samples=10^draws)
#}
}
for(i in 8:8){
plot(draws_ABC[,i])
#for(j in 1:nChains){
#  lines(c(1+(j-1)*ns,j*ns), rep(M$startPar[j,i],2), col='red')
#}
}
parNames[13]
parNames[8]
ll[8]
ul[8]
q()
