## Run ABC-MCMC Sampling
cat(sprintf("-Running MCMC chains \n"))
start_time = Sys.time()
cl <- makeForkCluster(detectCores())
clusterExport(cl, c("objectiveFunction", "M", "ns", "delta", "dprior"))
out_ABCMCMC <- parLapply(cl, 1:nChains, function(i) ABCMCMC(objectiveFunction, M$startPar[i,], ns, M$Sigma, delta, dprior))
stopCluster(cl)
draws <- c()
scores <- c()
acceptanceRate <- c()
nRegularizations <- c()
for(i in 1:nChains){
draws <- rbind(draws, out_ABCMCMC[[i]]$draws)
scores <- c(scores, out_ABCMCMC[[i]]$scores)
acceptanceRate <- c(acceptanceRate, out_ABCMCMC[[i]]$acceptanceRate)
nRegularizations <- c(nRegularizations, out_ABCMCMC[[i]]$nRegularizations)
}
end_time = Sys.time()
time_ = end_time - start_time
time_
for(i in 1:27){
plot(draws[,i])
lines(c(1,1000), rep(M$startPar[1,i],2), col='red')
lines(c(1,1000), rep(M$startPar[2,i],2), col='green')
}
for(j in 1:nChains){
lines(c(1+(j-1)*ns,j*ns), rep(M$startPar[j,i],2), col='red')
}
for(i in 1:27){
plot(draws[,i])
for(j in 1:nChains){
lines(c(1+(j-1)*ns,j*ns), rep(M$startPar[j,i],2), col='red')
}
}
cl<-makeForkCluster(2)
parLapply(cl,1:2,function(i) cat("message ", i))
parLapply(cl,1:2,function(i) disp("message ", i))
tmp<-parLapply(cl,1:2,function(i) disp("message ", i))
tmp<-parLapply(cl,1:2,function(i) message("message ", i))
tmp<-parLapply(cl,1:2,function(i) warning("message ", i))
tmp<-parLapply(cl,1:2,function(i) warning("message "))
tmp<-parLapply(cl,1:2,function(i) error("message "))
tmp<-parLapply(cl,1:2,function(i) print("message "))
nRegularizations
acceptanceRate
i<-2
if (i>1){
precursors <- experimentsIndices[1:(i-1)]
objectiveFunction <- makeObjective(experiments[precursors], modelName, getScore, parMap, nCores)
draws <- checkFitWithPreviousExperiments(draws, objectiveFunction, delta)
}
i<-3
expInd <- experimentsIndices[i]
objectiveFunction <- makeObjective(experiments[expInd], modelName, getScore, parMap)
cat("#####Starting run for Experiments ", expInd, "######\n")
## If First Experimental Setting, Create an Independente Colupla
if(i==1){
message("- Initial Prior: uniform product distribution")
rprior <- rUniformPrior(ll, ul)
dprior <- dUniformPrior(ll, ul)
## Otherwise, Take Copula from the Previous Exp Setting and Use as a Prior
} else {
message("- New Prior: fitting Copula based on previous MCMC runs")
C <- fitCopula(draws, nCores)
rprior <- rCopulaPrior(C)
dprior <- dCopulaPrior(C)
}
## Run Pre-Calibration Sampling
message("- Precalibration")
pC <- preCalibration(objectiveFunction, npc, rprior)
## Get Starting Parameters from Pre-Calibration
M <- getMCMCPar(pC$prePar, pC$preDelta, delta=delta, num = nChains)
M$startPar <- matrix(M$startPar, nChains)
for(i in 1 : nChains){
stopifnot(dprior(M$startPar[i,])>0)
}
## Run ABC-MCMC Sampling
cat(sprintf("-Running MCMC chains \n"))
for(i in 1:27){
plot(draws[,i])
for(j in 1:nChains){
lines(c(1+(j-1)*ns,j*ns), rep(M$startPar[j,i],2), col='red')
}
}
start_time = Sys.time()
cl <- makeForkCluster(detectCores())
clusterExport(cl, c("objectiveFunction", "M", "ns", "delta", "dprior"))
out_ABCMCMC <- parLapply(cl, 1:nChains, function(i) ABCMCMC(objectiveFunction, M$startPar[i,], ns, M$Sigma, delta, dprior))
stopCluster(cl)
draws <- c()
scores <- c()
acceptanceRate <- c()
nRegularizations <- c()
for(i in 1:nChains){
draws <- rbind(draws, out_ABCMCMC[[i]]$draws)
scores <- c(scores, out_ABCMCMC[[i]]$scores)
acceptanceRate <- c(acceptanceRate, out_ABCMCMC[[i]]$acceptanceRate)
nRegularizations <- c(nRegularizations, out_ABCMCMC[[i]]$nRegularizations)
}
end_time = Sys.time()
time_ = end_time - start_time
beep(8)
install.packages("beepr")
library(beepr)
time_
nRegularizations
acceptanceRate
i
i<-3
if (i>1){
precursors <- experimentsIndices[1:(i-1)]
objectiveFunction <- makeObjective(experiments[precursors], modelName, getScore, parMap, nCores)
draws <- checkFitWithPreviousExperiments(draws, objectiveFunction, delta)
}
for(i in 1:27){
plot(draws[,i])
for(j in 1:nChains){
lines(c(1+(j-1)*ns,j*ns), rep(M$startPar[j,i],2), col='red')
}
}
disp("Experimental set",i,":",time_)
disp(time_)
time_
cat(time_)
print(time_)
print("Experimental set",i,":",time_)
print(c("Experimental set",i,":",time_))
cat("Experimental set",i,":")
print(time_)
cat(nRegularizations)
cat("Regularizations:",nRegularizations)
cat("Acceptance rate:", acceptanceRate)
cat("Number of draws after fitting with previous experiments:",dim(draws)[2])
cat("Number of draws after fitting with previous experiments:",dim(draws)[1])
beep(1)
remotes::install_github("a-kramer/rgsl")
remotes::install_github("a-kramer/SBtabVFGEN")
library(rgsl)
library(SBtabVFGEN)
library(UQ)
source("../UQ/R/ABCMCMCFunctions.R")
source("../UQ/R/copulaFunctions.R")
source("../UQ/R/import_from_SBtab.R")
source("../UQ/R/PreCalibration.R")
source("../UQ/R/prior.R")
source("../UQ/R/runModel.R")
SBtabDir <- getwd()
model = import_from_SBtab(SBtabDir)
#modelName <- checkModel(comment(model),paste0(comment(model),'.R'))
modelName <- checkModel(comment(model),paste0(comment(model),'_gvf.c'))
#source(paste(SBtabDir,"/",modelName,".R",sep=""))
parVal <- model[["Parameter"]][["!DefaultValue"]]
names(parVal)<-model[["Parameter"]][["!Name"]]
parNames <- model[["Parameter"]][["!Name"]]
# load experiments
experiments <- import_experiments(modelName, SBtabDir)
parMap <- function(parABC){
return(10^parABC)
}
# test simulation
print(experiments[[1]][['input']])
print(parVal)
out <- runModel(experiments, modelName, as.matrix(parVal), parMap)
# scale to determine prior values
defRange <- 1000
# Define Lower and Upper Limits for logUniform prior distribution for the parameters
ll <- c(parVal[1:19]/defRange, parVal[20]/1.9, parVal[21]/defRange, parVal[22:24]/1.25, parVal[25:26]/1.5, parVal[27]/2)
ul <- c(parVal[1:19]*defRange, parVal[20]*1.9, parVal[21]*defRange, parVal[22:24]*1.25, parVal[25:26]*1.5, parVal[27]*2)
ll = log10(ll) # log10-scale
ul = log10(ul) # log10-scale
# Define the experiments that have to be considered in each iteration of the for loop to compare simulations with experimental data
experimentsIndices <- c(3, 12, 18, 9, 2, 11, 17, 8, 1, 10, 16, 7)
# Define Number of Samples for the Precalibration (npc) and each ABC-MCMC chain (ns)
ns <- 25 # no of samples required from each ABC-MCMC chain
npc <- 5000 # pre-calibration
# Define ABC-MCMC Settings
delta <- 7 #0.01
# Define the number of Cores for the parallelization
nCores <- parallel::detectCores() %/% 2
nChains <- 4
set.seed(7619201)
# Define the score function to compare simulated data with experimental data
getScore	<- function(yy_sim, yy_exp, yy_expErr){
yy_sim <- (yy_sim-0)/(0.2-0.0)
ifelse(!is.na(yy_exp), yy_exp <- (yy_exp-100)/(171.67-100), Inf)
distance <- mean(((yy_sim-yy_exp)/(yy_expErr/(171.67-100)))^2, na.rm=TRUE)
#When output function is fixed:
#distance <- mean((yy_sim-yy_exp)/(yy_expErr)^2, na.rm=TRUE)
return(distance)
}
start_time = Sys.time()
for (i in 1:length(experimentsIndices)){
expInd <- experimentsIndices[i]
objectiveFunction <- makeObjective(experiments[expInd], modelName, getScore, parMap)
cat("#####Starting run for Experiments ", expInd, "######\n")
## If First Experimental Setting, Create an Independente Colupla
if(i==1){
message("- Initial Prior: uniform product distribution")
rprior <- rUniformPrior(ll, ul)
dprior <- dUniformPrior(ll, ul)
## Otherwise, Take Copula from the Previous Exp Setting and Use as a Prior
} else {
start_time_fitCopula <- Sys.time()
message("- New Prior: fitting Copula based on previous MCMC runs")
C <- fitCopula(draws, nCores)
rprior <- rCopulaPrior(C)
dprior <- dCopulaPrior(C)
cat("Fitting copula:")
print(Sys.time()-start_time_fitCopula)
}
beep(5)
## Run Pre-Calibration Sampling
message("- Precalibration")
start_time_preCalibration <- Sys.time()
pC <- preCalibration(objectiveFunction, npc, rprior)
cat("PreCalibration:")
print(Sys.time()-start_time_preCalibration)
beep(3)
## Get Starting Parameters from Pre-Calibration
M <- getMCMCPar(pC$prePar, pC$preDelta, delta=delta, num = nChains)
M$startPar <- matrix(M$startPar, nChains)
for(i in 1 : nChains){
stopifnot(dprior(M$startPar[i,])>0)
}
## Run ABC-MCMC Sampling
cat(sprintf("-Running MCMC chains \n"))
# run outer loop
start_time_ABC = Sys.time()
cl <- makeForkCluster(detectCores())
clusterExport(cl, c("objectiveFunction", "M", "ns", "delta", "dprior"))
out_ABCMCMC <- parLapply(cl, 1:nChains, function(i) ABCMCMC(objectiveFunction, M$startPar[i,], ns, M$Sigma, delta, dprior))
stopCluster(cl)
draws <- c()
scores <- c()
acceptanceRate <- c()
nRegularizations <- c()
for(i in 1:nChains){
draws <- rbind(draws, out_ABCMCMC[[i]]$draws)
scores <- c(scores, out_ABCMCMC[[i]]$scores)
acceptanceRate <- c(acceptanceRate, out_ABCMCMC[[i]]$acceptanceRate)
nRegularizations <- c(nRegularizations, out_ABCMCMC[[i]]$nRegularizations)
}
end_time = Sys.time()
time_ = end_time - start_time_ABC
cat("ABCMCMC for experimental set",i,":")
print(time_)
cat("Regularizations:", nRegularizations)
cat("Acceptance rate:", acceptanceRate)
beep(8)
if (i>1){
precursors <- experimentsIndices[1:(i-1)]
objectiveFunction <- makeObjective(experiments[precursors], modelName, getScore, parMap, nCores)
draws <- checkFitWithPreviousExperiments(draws, objectiveFunction, delta)
}
beep(1)
cat("Number of draws after fitting with previous experiments:",dim(draws)[1])
# Save Resulting Samples to MATLAB and R files.
cat("-Saving sample \n")
outFile <- paste(experimentsIndices[1:i], collapse="_")
timeStr <- Sys.time()
timeStr <- gsub(":","_", timeStr)
timeStr <- gsub(" ","_", timeStr)
outFileR <- paste("../PosteriorSamples/Draws",modelName,"nChains",nChains,"ns",ns,"npc",npc,outFile,timeStr,".RData",collapse="_",sep="_")
save(draws, parNames, file=outFileR)
#if (require(R.matlab)){
#	outFileM <- paste("../PosteriorSamples/Draws",modelName,"ns",ns,"npc",npc,outFile,timeStr,".mat",collapse="_",sep="_")
#	writeMat(outFileM, samples=10^draws)
#}
}
closeAllConnections()
remotes::install_github("a-kramer/rgsl")
remotes::install_github("a-kramer/SBtabVFGEN")
library(rgsl)
library(SBtabVFGEN)
library(UQ)
source("../UQ/R/ABCMCMCFunctions.R")
source("../UQ/R/copulaFunctions.R")
source("../UQ/R/import_from_SBtab.R")
source("../UQ/R/PreCalibration.R")
source("../UQ/R/prior.R")
source("../UQ/R/runModel.R")
SBtabDir <- getwd()
model = import_from_SBtab(SBtabDir)
#modelName <- checkModel(comment(model),paste0(comment(model),'.R'))
modelName <- checkModel(comment(model),paste0(comment(model),'_gvf.c'))
#source(paste(SBtabDir,"/",modelName,".R",sep=""))
parVal <- model[["Parameter"]][["!DefaultValue"]]
names(parVal)<-model[["Parameter"]][["!Name"]]
parNames <- model[["Parameter"]][["!Name"]]
# load experiments
experiments <- import_experiments(modelName, SBtabDir)
parMap <- function(parABC){
return(10^parABC)
}
# test simulation
print(experiments[[1]][['input']])
print(parVal)
out <- runModel(experiments, modelName, as.matrix(parVal), parMap)
# scale to determine prior values
defRange <- 1000
# Define Lower and Upper Limits for logUniform prior distribution for the parameters
ll <- c(parVal[1:19]/defRange, parVal[20]/1.9, parVal[21]/defRange, parVal[22:24]/1.25, parVal[25:26]/1.5, parVal[27]/2)
ul <- c(parVal[1:19]*defRange, parVal[20]*1.9, parVal[21]*defRange, parVal[22:24]*1.25, parVal[25:26]*1.5, parVal[27]*2)
ll = log10(ll) # log10-scale
ul = log10(ul) # log10-scale
# Define the experiments that have to be considered in each iteration of the for loop to compare simulations with experimental data
experimentsIndices <- c(3, 12, 18, 9, 2, 11, 17, 8, 1, 10, 16, 7)
# Define Number of Samples for the Precalibration (npc) and each ABC-MCMC chain (ns)
ns <- 25 # no of samples required from each ABC-MCMC chain
npc <- 5000 # pre-calibration
# Define ABC-MCMC Settings
delta <- 7 #0.01
# Define the number of Cores for the parallelization
nCores <- parallel::detectCores() %/% 2
nChains <- 4
set.seed(7619201)
# Define the score function to compare simulated data with experimental data
getScore	<- function(yy_sim, yy_exp, yy_expErr){
yy_sim <- (yy_sim-0)/(0.2-0.0)
ifelse(!is.na(yy_exp), yy_exp <- (yy_exp-100)/(171.67-100), Inf)
distance <- mean(((yy_sim-yy_exp)/(yy_expErr/(171.67-100)))^2, na.rm=TRUE)
#When output function is fixed:
#distance <- mean((yy_sim-yy_exp)/(yy_expErr)^2, na.rm=TRUE)
return(distance)
}
start_time = Sys.time()
for (i in 1:length(experimentsIndices)){
expInd <- experimentsIndices[i]
objectiveFunction <- makeObjective(experiments[expInd], modelName, getScore, parMap)
cat("#####Starting run for Experiments ", expInd, "######\n")
## If First Experimental Setting, Create an Independente Colupla
if(i==1){
message("- Initial Prior: uniform product distribution")
rprior <- rUniformPrior(ll, ul)
dprior <- dUniformPrior(ll, ul)
## Otherwise, Take Copula from the Previous Exp Setting and Use as a Prior
} else {
start_time_fitCopula <- Sys.time()
message("- New Prior: fitting Copula based on previous MCMC runs")
C <- fitCopula(draws, nCores)
rprior <- rCopulaPrior(C)
dprior <- dCopulaPrior(C)
cat("Fitting copula:")
print(Sys.time()-start_time_fitCopula)
}
beep(5)
## Run Pre-Calibration Sampling
message("- Precalibration")
start_time_preCalibration <- Sys.time()
pC <- preCalibration(objectiveFunction, npc, rprior)
cat("PreCalibration:")
print(Sys.time()-start_time_preCalibration)
beep(3)
## Get Starting Parameters from Pre-Calibration
M <- getMCMCPar(pC$prePar, pC$preDelta, delta=delta, num = nChains)
M$startPar <- matrix(M$startPar, nChains)
for(i in 1 : nChains){
stopifnot(dprior(M$startPar[i,])>0)
}
## Run ABC-MCMC Sampling
cat(sprintf("-Running MCMC chains \n"))
# run outer loop
start_time_ABC = Sys.time()
cl <- makeForkCluster(detectCores())
clusterExport(cl, c("objectiveFunction", "M", "ns", "delta", "dprior"))
out_ABCMCMC <- parLapply(cl, 1:nChains, function(i) ABCMCMC(objectiveFunction, M$startPar[i,], ns, M$Sigma, delta, dprior))
stopCluster(cl)
draws <- c()
scores <- c()
acceptanceRate <- c()
nRegularizations <- c()
for(i in 1:nChains){
draws <- rbind(draws, out_ABCMCMC[[i]]$draws)
scores <- c(scores, out_ABCMCMC[[i]]$scores)
acceptanceRate <- c(acceptanceRate, out_ABCMCMC[[i]]$acceptanceRate)
nRegularizations <- c(nRegularizations, out_ABCMCMC[[i]]$nRegularizations)
}
end_time = Sys.time()
time_ = end_time - start_time_ABC
cat("ABCMCMC for experimental set",i,":")
print(time_)
cat("Regularizations:", nRegularizations)
cat("Acceptance rate:", acceptanceRate)
beep(8)
if (i>1){
precursors <- experimentsIndices[1:(i-1)]
objectiveFunction <- makeObjective(experiments[precursors], modelName, getScore, parMap, nCores)
draws <- checkFitWithPreviousExperiments(draws, objectiveFunction, delta)
}
beep(1)
cat("Number of draws after fitting with previous experiments:",dim(draws)[1])
# Save Resulting Samples to MATLAB and R files.
cat("-Saving sample \n")
outFile <- paste(experimentsIndices[1:i], collapse="_")
timeStr <- Sys.time()
timeStr <- gsub(":","_", timeStr)
timeStr <- gsub(" ","_", timeStr)
outFileR <- paste("../PosteriorSamples/Draws",modelName,"nChains",nChains,"ns",ns,"npc",npc,outFile,timeStr,".RData",collapse="_",sep="_")
save(draws, parNames, file=outFileR)
#if (require(R.matlab)){
#	outFileM <- paste("../PosteriorSamples/Draws",modelName,"ns",ns,"npc",npc,outFile,timeStr,".mat",collapse="_",sep="_")
#	writeMat(outFileM, samples=10^draws)
#}
}
expInd <- experimentsIndices[i]
objectiveFunction <- makeObjective(experiments[expInd], modelName, getScore, parMap)
cat("#####Starting run for Experiments ", expInd, "######\n")
## If First Experimental Setting, Create an Independente Colupla
if(i==1){
message("- Initial Prior: uniform product distribution")
rprior <- rUniformPrior(ll, ul)
dprior <- dUniformPrior(ll, ul)
## Otherwise, Take Copula from the Previous Exp Setting and Use as a Prior
} else {
start_time_fitCopula <- Sys.time()
message("- New Prior: fitting Copula based on previous MCMC runs")
C <- fitCopula(draws, nCores)
rprior <- rCopulaPrior(C)
dprior <- dCopulaPrior(C)
cat("Fitting copula:")
print(Sys.time()-start_time_fitCopula)
}
beep(5)
## Run Pre-Calibration Sampling
message("- Precalibration")
i
i<-1
expInd <- experimentsIndices[i]
objectiveFunction <- makeObjective(experiments[expInd], modelName, getScore, parMap)
cat("#####Starting run for Experiments ", expInd, "######\n")
## If First Experimental Setting, Create an Independente Colupla
if(i==1){
message("- Initial Prior: uniform product distribution")
rprior <- rUniformPrior(ll, ul)
dprior <- dUniformPrior(ll, ul)
## Otherwise, Take Copula from the Previous Exp Setting and Use as a Prior
} else {
start_time_fitCopula <- Sys.time()
message("- New Prior: fitting Copula based on previous MCMC runs")
C <- fitCopula(draws, nCores)
rprior <- rCopulaPrior(C)
dprior <- dCopulaPrior(C)
cat("Fitting copula:")
print(Sys.time()-start_time_fitCopula)
}
beep(5)
## Run Pre-Calibration Sampling
message("- Precalibration")
start_time_preCalibration <- Sys.time()
pC <- preCalibration(objectiveFunction, npc, rprior)
cat("PreCalibration:")
print(Sys.time()-start_time_preCalibration)
beep(3)
## Get Starting Parameters from Pre-Calibration
M <- getMCMCPar(pC$prePar, pC$preDelta, delta=delta, num = nChains)
M$startPar <- matrix(M$startPar, nChains)
for(i in 1 : nChains){
stopifnot(dprior(M$startPar[i,])>0)
}
## Run ABC-MCMC Sampling
cat(sprintf("-Running MCMC chains \n"))
# run outer loop
start_time_ABC = Sys.time()
cl <- makeForkCluster(detectCores())
clusterExport(cl, c("objectiveFunction", "M", "ns", "delta", "dprior"))
out_ABCMCMC <- parLapply(cl, 1:nChains, function(i) ABCMCMC(objectiveFunction, M$startPar[i,], ns, M$Sigma, delta, dprior))
closeAllConnections()
rm()
rm(all.vars())
cl
rm(cl)
expInd <- experimentsIndices[i]
objectiveFunction <- makeObjective(experiments[expInd], modelName, getScore, parMap)
cat("#####Starting run for Experiments ", expInd, "######\n")
## If First Experimental Setting, Create an Independente Colupla
if(i==1){
message("- Initial Prior: uniform product distribution")
rprior <- rUniformPrior(ll, ul)
dprior <- dUniformPrior(ll, ul)
## Otherwise, Take Copula from the Previous Exp Setting and Use as a Prior
} else {
start_time_fitCopula <- Sys.time()
message("- New Prior: fitting Copula based on previous MCMC runs")
C <- fitCopula(draws, nCores)
rprior <- rCopulaPrior(C)
dprior <- dCopulaPrior(C)
cat("Fitting copula:")
print(Sys.time()-start_time_fitCopula)
}
beep(5)
## Run Pre-Calibration Sampling
message("- Precalibration")
start_time_preCalibration <- Sys.time()
pC <- preCalibration(objectiveFunction, npc, rprior)
cat("PreCalibration:")
print(Sys.time()-start_time_preCalibration)
beep(3)
## Get Starting Parameters from Pre-Calibration
M <- getMCMCPar(pC$prePar, pC$preDelta, delta=delta, num = nChains)
M$startPar <- matrix(M$startPar, nChains)
for(i in 1 : nChains){
stopifnot(dprior(M$startPar[i,])>0)
}
## Run ABC-MCMC Sampling
cat(sprintf("-Running MCMC chains \n"))
# run outer loop
start_time_ABC = Sys.time()
cl <- makeForkCluster(detectCores())
clusterExport(cl, c("objectiveFunction", "M", "ns", "delta", "dprior"))
out_ABCMCMC <- parLapply(cl, 1:nChains, function(i) ABCMCMC(objectiveFunction, M$startPar[i,], ns, M$Sigma, delta, dprior))
rm(cl)
q()
