---
title: "Uncertainty Quantification on AKAR4 (deterministic)"
---

```{r, include = FALSE}
knitr::opts_chunk$set(eval=TRUE, cache=TRUE,
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(uqsa)
library(SBtabVFGEN)
library(rgsl)
```

In this article, we will assume that you don't yet have `c` sources
prepared for your model. And rather than vfgen, or the RPN-derivative
package, we will use the uqsa (this package) code generating
functions.

# Locate Files

The first step is to load the SBtab model files
(with `dir` for non-example models):

```{r}
f  <- uqsa::uqsa_example("AKAR4")
sb <- SBtabVFGEN::sbtab_from_tsv(f)
```

From the `sb` variable (list of data frames with the file contents) we can create an ordinary
differential equation, this will print lots of text about how it
interprets the contents (printouts are omitted here):

```{r include=FALSE}
m  <- SBtabVFGEN::sbtab_to_vfgen(sb)
```

```{r eval=FALSE}
m  <- SBtabVFGEN::sbtab_to_vfgen(sb)
```

We will also load the experimental data:

```{r data}
ex <- SBtabVFGEN::sbtab.data(sb,m$conservationLaws)
```

We have loaded these constructs:

```{r summary}
print(names(sb))
print(names(ex))
print(names(m))
```

## Generate Code

We take `m` and generate c code from it, then write this code into a file (`AKAR4_gvf.c`):

```{r code}
C <- uqsa::generateCode(m)
cat(C,sep="\n",file="./AKAR4_gvf.c")
```

The `ex` variable holds the experimental data and instructions about
how they correspond to model simulations (`ex` is a list).

Next, we check that the c sources exist in the specified location,
that the model compiles on the current system, with the default c
compiler (called by `checkModel`) and a shared library can be built:

```{r check}
modelName <- checkModel("AKAR4",modelFile="./AKAR4_gvf.c")
```

The function `checkModel` also appends the location of the shared library as a comment to its return value.

For a test simulation we create the function `s` which will remember the experiments to simulate and the model to simulate them with:

```{r test}
s <- simcf(ex,modelName,parMap=log10ParMap) # or simulator.c
p <- log10(sb$Parameter[["!DefaultValue"]])
names(p) <- rownames(sb$Parameter)
y <- s(p) # here the simulation happens
```

The function/closure `s` maps parameter vectors to model solutions (trajectories):

```{r plot}
ylab <- colnames(ex[[1]]$outputValues)
d_ <- ex[[1]]$outputValues[[1]]
e_ <- ex[[1]]$errorValues[[1]]
t_ <- ex[[1]]$outputTimes
f_ <- y[[1]]$func[1,,1]
par(bty="n")
plot(t_,d_,type="p",main=names(ex)[1],xlab="time",ylab=ylab,ylim=c(100,200))
arrows(t_,d_,t_,d_+e_,angle=90,length=0.01)
arrows(t_,d_,t_,d_-e_,angle=90,length=0.01)
lines(t_,f_,lw=3)
```

## Take a parameter Sample for this Model

We use just one core as this is a tiny model. No MPI, no parallel tempering:

```{r prior}
sd <- rep(2,length(p))
dprior <- dNormalPrior(p,sd)
rprior <- rNormalPrior(p,sd)
```

The function `mcmcUpdate` will automatically determine that the
Metropolis Hastings Algorithm should be used with these inputs:

```{r likelihood}
llf <- logLikelihoodFunc(ex)
metropolis_hastings <- mcmcUpdate(s,ex,logLikelihood=llf,dprior=dprior)
MH_MCMC <- mcmc(metropolis_hastings)
```

Obtain a sample of parameters:

```{r sample, fig.width=12, fig.height=12, dpi=100}
x <- mcmcInit(
    1.0,
    parMCMC=p,
    simulate=s,
    logLikelihood=llf,
    dprior=dprior)

h <- 5e-2
N <- 6e4
start_time <- Sys.time()
S <- MH_MCMC(x,N,eps=h)
cat(sprintf("Time spent sampling: %i seconds\n",round(difftime(Sys.time(),start_time,units="secs"))))
colnames(S) <- names(p)
print(attr(S,"acceptanceRate"))

if (require(hexbin)){
    hexplom(S,xbins=16)
} else {
    pairs(S)
}
```

## Better Sample

We can try to obtain a higher quality sample, through simple means:

1. Combine several samples (replicas) into one big sample
2. Use several random starting locations
3. Remove burn-in phase from each chain
4. Adjust the step size at least once to get close to 25% acceptance rate

```{r betterSample, collapse=FALSE}
A <- function(a) {
    return(0.5 + a^4/(0.25^4 + a^4))
}

set.seed(137)

start_time = Sys.time()

nCores <- parallel::detectCores()
bigSample <- parallel::mclapply(
    seq(nCores),
    \(i) {
        x <- mcmcInit(
            1.0,
            parMCMC=t(rprior(1)),
            simulate=s,
            logLikelihood=llf,
            dprior=dprior)
        ## adjust acceptance rate to 25% via step-size h
        for (i in seq(30)){
            z <- MH_MCMC(x,200,h)
            x <- attr(z,"lastPoint")
            h <- h*A(attr(z,"acceptanceRate"))
        }
        return(MH_MCMC(x,N,h))
    },
    mc.cores=nCores
)

end_time = Sys.time()
time_ = difftime(end_time,start_time,units="mins")
cat(sprintf("Time spend on sampling: %f minutes\n",time_))


S_ <- Reduce(\(a,b) {rbind(a,b)},bigSample,init=NULL)
L_ <- Reduce(\(a,b) {c(a,attr(b,"logLikelihood"))},bigSample,init=NULL)
colnames(S_) <- names(p)

if (require(hadron)){
    ac <- hadron::uwerr(data=L_,nrep=rep(N,nCores),pl=TRUE)
    tau <- ceiling(ac$tauint+ac$dtauint)
    i <- seq(1,NROW(S_),by=tau)
    cat(sprintf("tau: %i Â± %i\n",round(ac$tauint),round(ac$dtauint)))
    cat(sprintf("Effective sample size: %i\n",round((nCores*N)/(2*tau))))
} else {
    i <- seq(1,NROW(S_),by=100)
    plot(L_,type="l",xlab="mcmc index",ylab="log-likelihood")
}
```

And finally, we produce the same pairwise density plot (binning) or scatterplots:

```{r pairs-2, fig.width=12, fig.height=12, dpi=100}
if (require(hexbin)){
    hexbin::hexplom(S_[i,],xbins=16)
} else {
    pairs(S_[i,])
}
```

The code above can of course also be done in a loop (sequentially), and `rbind` within the loop.

Let us also plot the log-likelihood

```{r}
plot(L_,main="Big Sample for AKAR4",xlab="Markov chain index",ylab="log-likelihood", type="l")
```

This should be enough for this model size. For bigger models we turn
to either more advanced MCMC algorithms, such as SMMALA or parallel
tempering combined with the Metropolis-Hastings algorithm.

## Alternative to `checkModel()`

The steps described above to compile the model with the `checkModel`
function can also be done outside of R, by running an appropriate
command, e.g.:

```{sh, eval=FALSE}
# alternative, directly in the shell:
cc -shared -fPIC -o AKAR4.so ./AKAR4_gvf.c -lgsl -lgslcblas -lm
```


