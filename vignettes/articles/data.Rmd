---
title: "Importing Data"
---

```{r, include = FALSE}
knitr::opts_chunk$set(cache = TRUE, eval=FALSE,
  collapse = TRUE,
  comment = "#>"
)
```

The data is part of the SBtab document, but it can also be seen as
separate from the model, so it's imported with a different function.
This function also loads the inputs and initial values for the
model. When determining the inputs, the function takes conservation
laws into account and calculates input values for conserved
quantities, based on the stated initial values. The imported object `ex` is
a list of simulation instructions:

```{r, eval=TRUE}
library(uqsa)
library(SBtabVFGEN)

f <- uqsa_example('AKAR4cl')                         # file names
sb <- SBtabVFGEN::sbtab_from_tsv(f)                  # a list of data.frames
cl <- readRDS(uqsa_example('AKAR4cl',f="RDS"))       # previously saved laws
ex <- SBtabVFGEN::sbtab.data(sb,cl)                  # includes the data
ex[[1]]$input
ex[[1]]$initialState
```

The data-sets themselves can be stored in a normal SBtab table, using
any valid `TableName`. How many data sets there are and their type are
listed in the *table of experiments*: `Experiments.tsv`.  Data not
listed in the table of experiments is not loaded with the `sbtab.data`
function:

```{r, label='Experiments', eval=TRUE}
sb$Experiments
# The first one has this data-set
head(ex$AKAR4_400nM$outputValues)
```

The values in `ex` are simulation instructions for all
experiments. 

|         item | type           | meaning                                                                    |
|-------------:|:--------------:|:---------------------------------------------------------------------------|
|        input | numeric vector | known input parameters                                                     |
|  initialTime | numeric vector | a scalar time $t_0$                                                        |
| initialState | numeric vector | initial state $x_0$ of the ode $\dot x = f(x(t),t,p=c(k,u))$, $x(t_0)=x_0$ |
|  outputTimes | numeric vector | a time vector that corresponds to when measurements were taken             |
|              |                |                                                                            |
| outputValues | data.frame     | the values of the data at the above outputTimes                            |
|  errorValues | data.frame     | an indication of the measurement error/noise (standard error)              |
|       events | list           | a sudden transformation event                                              |


But, any data sets not present in Experiments, are still
accessible:

```{r,label='sb data sets', eval=TRUE}
head(sb$AKAR4_400nM)
```

This works for any data set that has a TSV file - or a sheet in any
other valid format (ods, xlsx). This table is just not a simulation
instruction:

- `sb` has the values of all tsv files/sheets
- `ex` has data and simulation instructions for the rgsl package

Each experiment is a time series experiment, after the import (dose
response sets are converted to one time series experiment per point).

More about this topic can be found in the [SBtab](SBtab.html) section. 

The rest of this page explains SBtab features that are related to
data-sets and experiment descriptions.





---

## Time Series

In a time series table, the first column is called `!TimePoint`, the
second is typically `!Time`, followed by the measured quantities
labelled as `>outputFunctionID` (values) and `~outputFunctionID` (error estimates).


|             Label | Example            | Meaning                                                                 |
|------------------:|:------------------:|:------------------------------------------------------------------------|
|        !TimePoint | `Experiment0Time0` | same as !ID, but for times (a unique string)                            |
|             !Time | `-0.5`             | a floating point constant                                               |
| >outputFunctionID | `>Calcium_Out`     | values that are meant to be compared to the Output called `Calcium_Out` |
| ~outputFunctionID | `~Calcium_Out`     | error estimated for the values in *>outputFunctionID*                   |

Each time series typically requires one model simulation to reproduce
(unless scheduled events are happening).

### Example Time Series

```
!!SBtab Document='myModel' TableName='DataSetBeta'
 !TimePoint  !Time    >A_out  ~A_out      >totalB  ~totalB 
       E0T0   -1.0      1.20  0.012         201.1  12
       E0T1   +0.0      11.8  0.12          203.2  11
       E0T2   +1.0      31.7  0.19          198.7  13
```

## Dose Response

An experiment that maps an increasing input to output values. In such
cases the output has to happen at one pre-defined time-point for each
dose. These dose-response curves will be transformed into *n*
time-series experiments during parsing, where *n* is the number of
content-rows (without headers).

|             label | example            | meaning                                                                 |
|------------------:|:------------------:|:------------------------------------------------------------------------|
|               !ID | `Experiment0Dose0` | a unique string, identifying this dose                                  |
|          >anInput | `300`              | a valid value for one of the input parameters                           |
| >outputFunctionID | `>Calcium_Out`     | values that are meant to be compared to the Output called `Calcium_Out` |
|                   |                    |                                                                         |
| ~outputFunctionID | `~Calcium_Out`     | error estimated for the values in *>outputFunctionID*                   |

A dose response curve requires *n* simulations of the model to reproduce.

### Example Dose Response Curve

This curve has two inputs and one output (`A_final`), each line is a separate time
series with one (final) _measurement time point_.

```
!!SBtab Document='myModel' TableName='DataSetGamma'
  !ID  >treatment_dose  >treatment_duration  >A_final  ~A_final 
 E0D0  200                50                     50.1  1.2
 E0D1  1000               50                     83.2  0.9
 E0D2  7000               25                     74.7  1.8
```

Anything more complex has to be expressed as a `Time series` with an
event schedule. The measurement time is taken from the `Experiments`
table (Experiments.tsv).

# Scheduled Events

An experiment can contain sudden events, in *systems biology* this is
useful to describe experiments that include an intervention at a
specified time (activation, silencing, stimulus, action potential,
etc.). These events happen much faster than the system dynamics and
modelling them exactly would slow down the solver dramatically. In the
case of an event at time $t$, the solver is stopped, a 
transformation to the current state $x(t)$ and parameters $p$ is
applied (in our C code, in the `rgsl` package, not with `deSolve`):

The SBtab table `Transformation` (`Tranformation.tsv` as a file)
defines which transformations the system is subject to.

An event table defines for each experiment, when the transformations apply.

The transformation function (C code), is auto-generated by [RPN-derivative/sh/ode.sh](icpm-kth/RPN-derivative).

An example of a Transformation table:

```
!!SBtab  Document='myModel'  TableName='Transformation' 
   !ID  >Cag      >Cal      >Vph        >Vpl        >Nu
  APCa  Cag+dCag  Cal+dCal  Vph         Vpl         Nu
   APV  Cag       Cal       Vphph*Vph   Vplpl*Vpl   Nu+ph*Vph+pl*Vpl 
 Tsucr  Cag       Cal       0           0           Nu+Vph+Vpl
```

These transformations apply at times given in an event schedule:

```
!!SBtab  Document='myModel'  TableName='OneAP'
 !ID  !Time  !Transformation  !Dose 
 AP0  0      APCa             0
 AP1  1E06   APV              0
```

And this schedule is applied to an experiment by listing it in the Experiment table:

```
!!SBtab  Document='myModel'  TableName='Experiment' 
    !ID  !Event  !T0   >A  >B
    PvR  OneAP    200  0   0
```

The `!Event` column specifies the event schedule for this experiment
(each experiment is one row).

This setup will create this C function:

```{c, eval=FALSE}

/* Scheduled Event function,
   EventLabel specifies which of the possible transformations to apply,
   dose can specify a scalar intensity for this transformation. */
int myModel_event(double t, double y_[], void *par, int EventLabel, double dose)
{
	double *p_=par;
	if (!y_ || !par || EventLabel<0) return 3;
	enum eventLabel { APCa,APV,Tsucr, numEvents }; /* event name indexes */
	enum stateVariable { var_Cag,var_Cal,var_Vdh,var_Vdl,var_Vph,var_Vpl,var_Np,var_Nu, numStateVar }; /* state variable indexes  */
	enum param { par_k1f,par_k1b,par_k2f,par_k2b,par_k3f,par_k4f,par_k5f,par_taug,par_taul,par_dCagDef,par_dCalDef,par_Kh,par_c,par_p3Def,par_p4,par_Ntot,par_cMutE,par_BasuE,par_cMutB,par_BasuB,par_BasuKIB,par_Cag0Def,par_Cal0Def, numParam }; /* parameter indexes  */
	
	/* model specific code that defines the local variables, but isn't important: */
	/* ... */
	double k1f=p_[0]; // etc.
	/* ... */
	double Cag=y_[0]; // etc.
	/* ... */

	switch(EventLabel){
	case APCa:
		y_[var_Cag] = Cag+dCag;
		y_[var_Cal] = Cal+dCal;
	break;
	case APV:
		y_[var_Vph] = Vph-ph*Vph;
		y_[var_Vpl] = Vpl-pl*Vpl;
		y_[var_Nu] = Nu+ph*Vph+pl*Vpl;
	break;
	case Tsucr:
		y_[var_Vph] = 0;
		y_[var_Vpl] = 0;
		y_[var_Nu] = Nu+Vph+Vpl;
	break;
	}
	return GSL_SUCCESS;
}

```

# Gaussian Measurement errors

For Gaussian noise, `errorValues` can be the standard deviation of the
mean (standard error). the data frame has the same shape and names as
the output values. The usual way to write this somewhere is typically

```
outputValues Â± errorValues
```

For other error models, or noise distributions, the user can decide
what kind of values are useful and use them in their custom scoring
functions (untested by us).
