---
title: "Importing Models into R"
---

```{r, include = FALSE}
knitr::opts_chunk$set(cache = TRUE,
  collapse = TRUE,
  comment = "#>"
)
```

If the model can be described in terms of reactions, inputs, and
outputs, then the most straightforward way to define it is through
[SBtab tables](./SBtab.html). 

For completely different models (or solvers), the user must either write their own
likelihood function (cost-function/objective-function) or write a vf
file manually to generate C code from.

It is also possible to directly write the model functions in C (for `gsl_odeiv2`).

```R
f <- dir(pattern="[.]tsv$",full.names=TRUE)          # file names
sb <- SBtabVFGEN::sbtab_from_tsv(f)                  # a list of data.frames
cl <- SBtabVFGEN::sbtab_to_vfgen(sb)                 # conservation laws, if any
ex <- SBtabVFGEN::sbtab.data(sb,cl)
```

The function `sbtab_to_vfgen` will produce several files, using the
model's name (`Document='model_name'` attribute of SBtab):

- `model_name.vf`, a vfgen compatible file
- `model_name.mod`, a NEURON mod file
- (optional) `model_name.xml`, an SBML file, if you have the R bindings to libsbml installed in R and libsbml in your system
- `*.txt`, the math for the ODE system, not tied to any specification (human readable math text files)
- `model.tar.gz`, the same text files, bundled as a zip
- `model.zip`, the same as `tar.gz` but for people who only know `zip`, for compatibility

The vf file is compatible with the
[vfgen](https://warrenweckesser.github.io/vfgen/) tool, which creates
code in many languages from this `vf` file (matlab, cvode, octave,
python, xppaut). Use this tool if you want to use the created source
code for other programming languages. Some SBtab content will be
missing here (e.g. scheduled events). The vfgen tool uses the
[ginac](https://www.ginac.de/) library to calculate Jacobians.  Ginac
cannot parse vf files with inequality expressions in them (e.g. `a < b`).


The `ex` variable will hold simulation instructions as a plain R list:
inputs, initial values, measurement times, etc.

## Converting the ODE to code

We use our tool, [RPN-derivative](github.com/icpm-kth/RPN-derivative),
which reads the same file (or one of the archive files:
`zip`/`tar.gz`) to create slightly different C code. The main
advantages are:

- a vector valued output function with a predictable name: `int MODEL_func()`
- the error code of each function is the length of the output buffers that need to be allocated
- more functions are created:
    + initial conditions: `int MODEL_init()`
	+ default parameter values: `int MODEL_default()`

The repository of this tool, [icpm-kth/RPN-derivative](icpm-kth/RPN-derivative),
contains a shell script [ode.sh](icpm-kth/RPN/derivative/sh/ode.sh);
this script uses one of three methods to calculate analytical
derivatives for the Jacobians:
1. [maxima](https://maxima.sourceforge.io/),
2. [yacas](https://yacas.readthedocs.io/en/latest/),
3. the `bin/derivative` binary that RPN-derivative contains (after `make && make install`)


Assuming that you followed all [installation instructions](articles/installation.html):

```{sh, eval=FALSE}
ode -R --maxima ./myModel.vf > ./myModel.R 
```

```{sh, eval=FALSE}
ode -C --maxima ./myModel.tar.gz > ./myModel_gvf.c
```

Note: `ode.sh` is compatible with the same vf files from SBtabVFGEN,
but doesn't support all of the output formats that VFGEN can do, and
does nothing related to delays.

# Background on Parameters vs Inputs

Our goal is to perform *parameter estimation*. A *systems biology*
model typically has parameters that are either reaction rate
coefficients $k_f$, equilibrium constants $K_d$, Hill coefficients,
and many other quantities related to *kinetc laws*; they are often
unknown or not uniquely determined yet. But, not all parameters of a
model are unknown, and not all model parameters are intrinsic to the
system we study. Some of them model the interventions we do to the
model when performing an experiment. This could be the frequency of a
driving force for a mechanical model, or the amount of a treatment
dose (added to the system) that affects the time course of reactions:

- a substrate, or buffer
- an enzyme,
- a silencing agent,
- an inhibitor

These parameters are known to us, because they are written down in the
protocol. If the input is time dependent, then its dynamics (or
explicit algebraic functions) have to become part of the model. These
input parameters can be different between experiments, but the
intrinsic parameters are always the same.

The ordinary differential equation on the other hand does not need to
know the distinction between known or unknown parameters. For these
reasons:

```R
parMCMC <- [...]             # some sampling variable
k <- parMap(parMCMC)         # a model compatible parameter vector
u <- experiments[[i]]$input  # a valid model input vector
p <- c(k,u)
# solve ODE using p
```

where `k` are intrinsic, unknown parameters (subject to sampling), and
`u` are the known input parameters that are encoded in the `input`
field of an experiment.

If input parameters `u` exist, then they are always concatenated (`p <-c(k,u)`) 
in that order and passed to the model, the model's C code
only sees `p`. The wrapper functions in the `rgsl` package do this
concatenation when the solver is called. We sample in
logarithmic space, but the solver gets `k` and appends
the right `u` for each experiment, both in linear space.

So, if `parMCMC` is in log10-space, then `parMap` is the
transformation to linear-space for the solver to work in:

```
parMap <- function(par) {
    return(10^(par))
}
```
